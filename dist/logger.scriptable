{
  "always_run_in_app": false,
  "icon": {
    "color": "deep-gray",
    "glyph": "pen-fancy"
  },
  "name": "logger",
  "script": "'use strict';\n\n/**\n * @file logger.js\n * @author Kynako\n * @license MIT license\n * @see https://github.com/Kynako/scriptable-logger\n * @version 1.1.0\n */\n\n/**\n * ERR_MSGS\n * @constant {{String: String|Function}}\n * @package\n */\nconst ERR_MSGS = {\n  INVALID_TYPE: (name, expected, an=false) => `Supplied ${name} is not ${an ? 'an' : 'a'} ${expected}.`,\n  TIMER_NOT_EXIST: label => `Timer '${label} doesn't exist.`\n};\n\n/**\n * LGRError\n * @class\n * @extends Error\n * @param {any} msg\n */\nclass LGRError extends Error {\n  \n  /**\n   * constructor(msg)\n   * @constructor\n   * @param {String} msg\n   * @return {LRGError}\n   */\n  constructor(msg) {\n    super(msg);\n    this.name = this.constructor.name;\n  };\n};\n\n/**\n * Logger\n * @class\n * @description \n *   A class to log something.\n */\nmodule.exports = class Logger {\n  \n  /**\n   * @property {Number} [groupIndentation=2]\n   * @static\n   * @public\n   */\n  static groupIndentation = 2;\n  \n  /**\n   * @property {Number} [#amountOfGroupInfemtation=0];\n   * @stric\n   * @private\n   */\n  static #groupIndentationCount = 0;\n  \n  /**\n   * @property {Map<K, V>} #counter\n   * @static\n   * @private\n   */\n  static #counter = new Map();\n  \n  /**\n   * @property {Map<K, V>} #timer\n   * @static\n   * @private\n   */\n  static #timer = new Map();\n  \n  /**\n   * +#createLogMessage(value)\n   * @method\n   * @static\n   * @private\n   * @param {any} [value]\n   */\n   static #createLogMessage = (value) => {\n     const indent = this.#getCurrentIndentString();\n     return indent + _scriptable_createLogMessage(value);\n   };\n   \n   /**\n    * +#getCurrentIndentString()\n    * @method\n    * @static\n    * @private\n    * @return {String}\n    */\n    static #getCurrentIndentString = () => {\n      return ' '\n       .repeat(this.groupIndentation)\n       .repeat(this.#groupIndentationCount);\n    };\n  \n  /**\n   * +log([msg])\n   * @method\n   * @static\n   * @public\n   * @param {any} [msg]\n   */\n  static log = (msg) => {\n    _scriptable_log(\n      this.#createLogMessage(msg)\n    );\n  };\n  \n  /**\n   * +warn([msg])\n   * @method\n   * @static\n   * @public\n   * @param {any} [msg]\n   */\n  static warn = (msg) => {\n    _scriptable_logWarning(\n      this.#createLogMessage(msg)\n    );\n  };\n  \n  /**\n   * +error([msg])\n   * @method\n   * @static\n   * @public\n   * @param {any} [msg]\n   */\n  static error = (msg) => {\n    _scriptable_logError(\n      this.#createLogMessage(msg)\n    );\n  };\n  \n  /**\n   * +assert(assertion[, msg])\n   * @method\n   * @static\n   * @public\n   * @param {any} assertion\n   * @param {any} [message]\n   */\n  static assert = (assertion, msg) => {\n    if(!assertion) this.error(msg);\n  };\n  \n  /**\n   * +group()\n   * @method\n   * @static\n   * @public\n   */\n   static group = () => {\n     this.#groupIndentationCount++;\n   };\n  \n  /**\n   * +groupEnd()\n   * @method\n   * @static\n   * @public\n   */\n   static groupEnd = () => {\n     this.#groupIndentationCount--;\n   };\n   \n  /**\n   * +count([label])\n   * @method\n   * @static\n   * @param {String} [label='default']\n   */\n  static count = (label = 'default') => {\n    if(typeof label !== 'string') {\n      throw new LGRError(\n        ERR_MSGS.INVALID_TYPE('label', 'String')\n      );\n    };\n    let count = this.#counter.get(label) ?? 0;\n    this.log(label + ': ' + ++count);\n    this.#counter.set(label, count);\n  };\n  \n  /**\n   * +countReset([label])\n   * @method\n   * @static\n   * @param {String} [label='default']\n   */\n  static countReset = (label = 'default') => {\n    if(typeof label !== 'string') {\n      throw new LGRError(\n        ERROR_MSGS.INVALID_TYPE('label', 'String')\n      );\n    };\n    this.#counter.set(label, 0);\n    this.log(label + ': ' + 0);\n  };\n  \n  /**\n   * +time([label])\n   * @method\n   * @static\n   * @param {String} [label='default']\n   */\n  static time = (label='default') => {\n    if(typeof label !== 'string') {\n      throw new LGRError(\n        ERR_MSGS.INVALID_TYPE('label', 'String')\n      );\n    };\n    \n    this.#timer.set(label, Date.now());\n  };\n  \n  /**\n   * +timeLog([label])\n   * @method\n   * @static\n   * @param {String} [label='default']\n   */\n  static timeLog = (label='default') => {\n    if(typeof label !== 'string') {\n      throw new LGRError(\n        ERR_MSGS.IMVALID_TYPE('label', 'String')\n      );\n    };\n    const time = this.#timer.get(label);\n    if(!time) {\n      throw new LGRError(\n        ERR_MSGS.TIMER_NOT_EXIST(label)\n      );\n    };\n    const elapsed = Date.now() - time;\n    this.log(label + ': ' + elapsed + 'ms');\n  };\n  \n  /**\n   * +timeEnd([label])\n   * @method\n   * @static\n   * @param {String} [label='default']\n   */\n  static timeEnd = (label='default') => {\n    if(typeof label !== 'string') {\n      throw new LGRError(\n        ERR_MSGS.INVALID_TYPE('label', 'String')\n      );\n    };\n    const time = this.#timer.get(label);\n    if(!time) {\n      throw new LGRError(\n        ERR_MSGS.TIMER_NOT_EXIST(label)\n      );\n    };\n    const elapsed = Date.now() - time;\n    this.log(label + ': ' + elapsed + 'ms');\n    this.#timer.delete(label);\n  };\n  \n  /**\n   * +pretty(value[, replacer[, space]])\n   * @method\n   * @static\n   * @public\n   * @param {any} value\n   * @param {Function|Null} [replacer=null]\n   * @param {String|Number} [space=2]\n   */\n  static pretty = (value, replacer=null, space=2) => {\n    const stringified = JSON.stringify(value, replacer, space);\n    this.log(stringified);\n  };\n};",
  "share_sheet_inputs": [

  ]
}
